#ifndef sgf_node
#module sgf_node

#define KEY_VALUE_SEP "|||"

#define MAX_NODE 1500000

#deffunc init_sgf_module
	dim parent, MAX_NODE //親ノード
	
	dim sgf_node_turn, MAX_NODE //ノードの手番
	dim sgf_node_x, MAX_NODE //ノードの座標ｘ
	dim sgf_node_y, MAX_NODE //ノードの座標ｙ
	sdim sgf_properties_data,, MAX_NODE //その他のプロパティ
	dim sgf_properties_num,MAX_NODE //その他のプロパティの数

	sdim sgf_node_childs,, MAX_NODE //子ノードリスト
	dim child_num, MAX_NODE //子ノードの数

	//------------------------------------
	sdim open_id_list //配列の空き情報リスト
	dim open_id_list_num //配列の空き情報の数
	
	node_count = 0 //配列の最大（未使用要素も含む）

	SEP = " "
	poke SEP, 0, $1F
	
	return

#defcfunc make_new_SGFnode int p1
	if open_id_list_num{
		open_id_list_num--
		new_id = open_id_list(open_id_list_num)
	}else{
		new_id = node_count
		node_count++
	}

	init_node new_id, p1
	
	return new_id

#deffunc add_sgf_property int node_id, str s1, str s2

	sgf_properties_data(node_id) += s1 + KEY_VALUE_SEP + s2 + SEP
	sgf_properties_num(node_id)++
	
	return
#deffunc del_sgf_property int node_id, str s1

	dup data, sgf_properties_data(node_id)
	
	index = instr(data, 0, SEP + s1 + KEY_VALUE_SEP)
	if index == -1: return
	
	next_index = index + 1 + instr(data, index + 1, SEP)

	left = strmid(data, 0, index)
	right = strmid(data, next_index, 999999)

	data = left + right

	sgf_properties_num(node_id)--

	return

#deffunc add_SGFchild int node_id, int p1
    if search_SGFchild(node_id, p1) == -1 {
        index = child_num(node_id) * 4  // 4バイト単位で格納
        memexpand sgf_node_childs(node_id), index + 4
        lpoke sgf_node_childs(node_id), index, p1
        child_num(node_id)++
    }
    return

#deffunc del_sgf_node int node_id
	open_id_list(open_id_list_num) = node_id
	open_id_list_num++
	init_node node_id, -1
	return

#deffunc set_property_data int node_id, str s, str d
	if s == "B"{
		sgf_node_turn(node_id) = 1
		tmp = d
		sgf_node_x(node_id) = peek(tmp, 0) - 'a'
		sgf_node_y(node_id) = peek(tmp, 1) - 'a'
	}else: if s == "W"{
		sgf_node_turn(node_id) = 2
		tmp = d
		sgf_node_x(node_id) = peek(tmp, 0) - 'a'
		sgf_node_y(node_id) = peek(tmp, 1) - 'a'
	}else{
		//登録
		del_sgf_property node_id, s
		add_sgf_property node_id, s, d
	}
	return

#defcfunc get_property_data int node_id, str property_name
	dup data, sgf_properties_data(node_id)
	
	// プロパティの名前と値を探す
	index = instr(data, 0, SEP + property_name + KEY_VALUE_SEP)
	if index == -1: return ""  // 見つからなかった場合は空文字を返す
	
	// データの最後までのインデックスを取得
	next_index = index + 1 + instr(data, index + 1, SEP) //最後のSEPは必ず存在する事はモジュール全体で保証。
	
	value_start = index + 1 + strlen(property_name) + strlen(KEY_VALUE_SEP) //+1はstrlen(SEP)
	value_end = next_index

	// プロパティの値を抽出して返す
	result = strmid(data, value_start, value_end - value_start)
	
	;logmes "@@@@" + result
	return result

#defcfunc get_property_coordinate_cash int node_id, array xy
	xy = sgf_node_x(node_id), sgf_node_y(node_id)
	return sgf_node_turn(node_id)

#defcfunc get_SGF_childs int node_id, array a
	dup a, sgf_node_childs(node_id)
	return child_num(node_id)

#defcfunc search_SGFchild int node_id, int target
    repeat child_num(node_id)
        if lpeek(sgf_node_childs(node_id), cnt * 4) == target : return cnt
    loop
    return -1

#defcfunc get_node_sgf int p1
	result = "("
	_get_node_sgf p1, result
	result += ")"
	return result

#deffunc _get_node_sgf int node_id, var s, local i, local n, local child

	s += ";"
	
	if sgf_node_turn(node_id) != -1{
		座標 = "  "
		poke 座標, 0, 'a' + sgf_node_x(node_id)
		poke 座標, 1, 'a' + sgf_node_y(node_id)
		
		if sgf_node_turn(node_id) == 1{
			s += "B[" + 座標 + "]"
		}else{
			s += "W[" + 座標 + "]"
		}
	}

	split sgf_properties_data(node_id), SEP, tmp
	repeat sgf_properties_num(node_id), 1
		split tmp(cnt), KEY_VALUE_SEP, kv
		if kv == "AB"{
			s += kv
			repeat strlen(kv.1) / 2
				s += "[" + strmid(kv.1,cnt*2,2) + "]"
			loop
		}else{
			s += kv + "[" + kv.1 + "]"
		}
	loop

	n = get_SGF_childs(node_id, child)
	for i,, n
	
		if n >= 2{
			s+="("
		}
		
		_get_node_sgf lpeek(child, i * 4), s
		
		if n >= 2{
			s+=")"
		}
	next

	return

#deffunc get_nodelist int node_id, array a
	dim a
	_get_nodelist node_id, a
	return
#deffunc _get_nodelist int node_id, array a, int num
	a(num) = node_id
	if parent(node_id) != -1{
		_get_nodelist parent(node_id), a, num + 1
	}
	return

//特定のノードまでのSGFを取得
#defcfunc get_node_sgf_nowpoint int p1, local i
	get_nodelist p1, a
	result = "("
	for i, length(a)-1,-1,-1
		result += get_node_sgf_nowpoint_main(a(i))
	next
	result += ")"
	return result
#defcfunc get_node_sgf_nowpoint_main int node_id, local i
	i = ";"
	if sgf_node_turn(node_id) != -1{
		座標 = "  "
		poke 座標, 0, 'a' + sgf_node_x(node_id)
		poke 座標, 1, 'a' + sgf_node_y(node_id)
		if sgf_node_turn(node_id) == 1{
			i += "B[" + 座標 + "]"
		}else{
			i += "W[" + 座標 + "]"
		}	
	}

	split sgf_properties_data(node_id), SEP, tmp
	repeat sgf_properties_num(node_id), 1
		split tmp(cnt), KEY_VALUE_SEP, kv
		if kv == "AB" || kv == "AW"{
			i += kv
			repeat strlen(kv.1)/2
				i += "[" + strmid(kv.1,cnt*2,2) + "]"
			loop
		}else{
			i += kv + "[" + kv.1 + "]"
		}
	loop
	return i

#deffunc local init_node int node_id, int p1

	parent(node_id) = p1
	sgf_node_turn(node_id) = -1
	sgf_node_x(node_id) = -1
	sgf_node_y(node_id) = -1
	sgf_properties_data(node_id) = SEP //SEPで始まりSEPで終わる形式で保存 (splitしたら、先頭と末尾は空になることに注意)
	sgf_properties_num(node_id) = 0
	
	sgf_node_childs(node_id) = ""
	child_num(node_id) = 0

	return
#global
init_sgf_module

#module
#defcfunc 対応する括弧まで取得 str ss, var index, str s1, str s2, var result
	s = ss
	counter = 0
	repeat , index
		t = strmid(s,cnt,1)
		if t == s1{
			counter++
		}else:if t == s2{
			counter--
		}
		if counter == 0: r2 = cnt: break
	loop
	result = strmid(s, index + 1, r2 - index - 1)
	return r2
#defcfunc 対応する文字まで取得 var ss, int index, str s1, var result

	i = instr(ss,index,s1)
	result = strmid(ss,index,i)
	return index + i
#global


#module

#defcfunc make_SGFnode int nownode, array coordinate, str 手番

	new = nownode

	座標 = "  "
	poke 座標, 0, 'a' + coordinate
	poke 座標, 1, 'a' + coordinate.1

	if nownode >= 0{
		if search_SGFchild_byxy(nownode, 手番, 座標) >= 0{
			return stat //すでにノードが存在
		}
	}
	
	
	new = make_new_SGFnode(nownode)
	if nownode >= 0: add_SGFchild nownode, new
	set_property_data new, 手番, 座標
		
	return new

#define global ctype load_sgf(%1, %2 = -1) _load_sgf(%1,%2)
#defcfunc _load_sgf str ss, int node
	
	sss = ss
	sgflen = strlen(sss)
	if sgflen < 3{
		//最小SGFは　(;)
		return -1
	}
	if (peek(sss) != '(') || (peek(sss, sgflen - 1) != ')'){
		return -1
	}
	start_point = instr(sss, 0 ,";")
	if start_point == -1{
		return -1
	}
	
	topnode = make_new_SGFnode(node)

	
	onerror *er
		load_sgf_main strmid(sss, start_point + 1, sgflen - start_point - 2), topnode
	onerror 0
	
	return topnode

*er
	dialog "エラーコード = "+err+"\n 総ノード数 -> " + length(node_count@sgf_node) + "\n 棋譜数 -> " + next_kifuload_index@,, __FILE__
	end

#deffunc load_sgf_main str ss, int node, local sgfs, local point, local nn, local sgf_length
	sgfs = ss
	nn = node
	
	sgf_length = strlen(sgfs)
	//解析
	while point < sgf_length
		
		token = peek(sgfs, point)
		
		if token >= 'A' && token <= 'Z'{
			
			point = 対応する文字まで取得(sgfs, point, "[", P) + 1
			point = 対応する文字まで取得(sgfs, point, "]", D) + 1
			set_property_data nn, P, D
			
		}else:if token = '('{
			
			point = 対応する括弧まで取得(sgfs, point, "(", ")", f) + 1
			load_sgf_main f, nn
			
		}else:if (token == ';'){
			
			new_id = make_new_SGFnode(nn)
			
			add_SGFchild nn, new_id
			nn = new_id
			point++
			
		}else:if token == '['{
			
			point++
			point = 対応する文字まで取得(sgfs, point, "]", D) + 1
			set_property_data nn, P, get_property_data(nn, P) + D
			
		}else{

			logmes "不正なトークンが含まれています"
			
			point++
			
		}
	wend
	return
#global
#endif

#if 0

mes get_node_sgf(load_sgf("(;B[ii] ;W[jj]  (; W[kk]C[ヒャッホー])  (;W[ll]))"))


#endif
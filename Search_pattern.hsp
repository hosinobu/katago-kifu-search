#ifndef search
#include "modules/keyfps.hsp" //タイマー -> ( keyfpstime )
#include "modules/sgf.hsp" //sgf関連-> ( load_sgf, get_SGF_childs, get_board_size_from_SGF )
#include "GobanPatternManager.hsp" //パターン関連-> ( make_rotated_patterns, PATTERN_BLACK, PATTERN_WHITE ) 
#include "modules/namespace_base.hsp" //ハッシュ関連-> ( get_value, new_value, NOT_DEFINED_HASH )
#include "modules/ringbuffer.hsp" //キュー関連-> ( ringbuffer_count, init_ringbuffer, r_push, r_shift )
#include "memorize_hit_rect.hsp" //検索用メモ化関連-> ( clear_mem, memorize_hit_rect )

#module
#defcfunc search str SGF_list, array pattern, array result, int max_depth, int colorflip, int kifu_update

	stone_num = get_pattern_all_stones_num(pattern) //パターン内の全ての石数を取得
	if stone_num == 0: return 0

	colorflip_num = 1 + colorflip
	
	最大の深さ = 50
	if max_depth{
		最大の深さ = max_depth
	}
	rn = 0
	prexy = -1, -1
	
	//logmes "探索を開始します-> 石数 = " + stone_num
	
	notesel ss
		ss = SGF_list
	
		titlestr = ""
	
		starttime = keyfpstime
	
		if kifu_update{		
			repeat , next_kifuload_index@
				noteget sgf_filename, cnt
				next_kifuload_index@++
				if sgf_filename == "": break
				if get_value(sgf_filename) == NOT_DEFINED_HASH{
					notesel sgf
						noteload sgf_filename
					noteunsel
					topnode = load_sgf(sgf)
					new_value sgf_filename, str(topnode)
					await
					titlestr = "棋譜読み込み中 -> "+ (cnt+1) * 100 / notemax + "%"
					title titlestr
				}
			loop
		}
	
		titlestr += strf("(%dms) -> 検索開始 -> ", keyfpstime - starttime)
		title titlestr
		
		starttime = keyfpstime
		repeat notemax
			noteget sgf_filename, cnt
			
			topnode = int(get_value(sgf_filename))
			
			get_board_size_from_SGF topnode, xy
	
			//前回検索した棋譜とボードサイズが違う場合
			if prexy != xy || prexy.1 != xy.1{
				//新たなパターンを生成
				make_rotated_patterns pattern, xy, xy.1 , rotated_p
				clear_mem
				prexy = xy,xy.1
				
			}
			
			//サーチメイン関数用の変数設定
			r_pattern_num = 4 << (xy == xy.1)
			all_pattern_num = r_pattern_num * colorflip_num
			
			//検索実行
			if search_main(topnode, rotated_p, match_node){
				result(0, rn) = sgf_filename //一致したSGFを結果に追加
				result(1, rn) = str(match_node)
				;logmes str(match_node)
				rn++
			}
			
		loop
	noteunsel

	title titlestr + strf("検索完了 %d件 (%dms)", rn, keyfpstime - starttime)
	
	return rn

#defcfunc search_main int t, array pattern, array result_node

/*
 t:
 - 検索開始のノード番号
 pattern:
 - 検索に使うパターン
 result_node:
 - 検索に一致した場合そのノード番号を返す

 return_value -> マッチしたかどうかの　1か0の値
*/

	//キュー初期化
	valid_pattern_count = 0
	repeat r_pattern_num
		for i,, colorflip_num
			vlist(0, valid_pattern_count) = i, cnt, 0
			valid_pattern_count++
		next
	loop

	lpoke node_data, , 1               //現在の深さ
	lpoke node_data,4, t               //
	lpoke node_data,8, all_pattern_num //全ての有効なパターン数
	memcpy node_data, vlist  , 48 * 4, 3 * 4
	r_push node_data
	
	*next_node
	while ringbuffer_count

		r_shift node_data //キューからノードデータを復元

		//ノードデータ展開
		depth = lpeek(node_data) : if depth > 最大の深さ: return 0
		node = lpeek(node_data, 4)
		valid_pattern_count = lpeek(node_data, 8)
		memcpy vlist  , node_data, 48*4,, 3 * 4
		
		turn = get_property_coordinate_cash(node, x, y) //ノードの手番、座標を取得

		if x >= 0{

			for v,, valid_pattern_count
				*check_pattern_list
			
				r_p = vlist(1, v)
				
				if memorize_hit_rect(r_p, x, y, pattern, hit_stone) == -1{
					_continue
				}
	
				if hit_stone >= 0{
					split pattern(stat, 1, vlist(0, v), r_p),"-", stones
					split stones(hit_stone), ":", stone_info
					if turn == 1{
						if PATTERN_BLACK & stone_info.2: goto *matched
					}else{
						;if turn == 2{
						if PATTERN_WHITE & stone_info.2: goto *matched
						;}
					}
				}
				
				valid_pattern_count--
				if v == valid_pattern_count{
					//有効パターンリストを全て探索した。
					if valid_pattern_count{
						//まだ有効リストが残っているので、子ノードを積みに行く
						_break
					}
					//有効なパターンがなくなった。　＝　このノードは可能性がなくなった。
					goto *next_node
				}
				//今の位置をパターンリストの末尾要素で置き換えて再探索
				memcpy vlist(0, v), vlist(0, valid_pattern_count), 12
				goto *check_pattern_list
				
				*matched
				vlist(2, v)++
				if vlist(2, v) == stone_num{
					result_node = node //一致したSGFノード
					; result_v = v //一致したパターン
					return 1 //検索成功
				}
			next
		}
		repeat get_SGF_childs(node, child)
			lpoke node_data,  , depth + 1
			lpoke node_data, 4, lpeek(child, cnt * 4)
			lpoke node_data, 8, valid_pattern_count
			memcpy node_data, vlist, 48 * 4, 3 * 4
			r_push node_data
		loop
	wend
	return 0

#deffunc search_init

	sdim result,, 2, 10000
	
	dim vlist , 3, 16
	; vlist = (色反転フラグ,回転パターンタイプ, マッチした数 ) が 最大で 16 要素
	;         (    0-1     ,  0-7             ,              )
	
	data_num = (3 + 16 * 3)
	init_ringbuffer data_num * 4, 512
	sdim node_data, data_num * 4 // キュー要素のデータ構造 51要素 * 整数(4バイト)
	return
#global
search_init
#endif
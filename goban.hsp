#ifndef goban
#include "modules/coordinate_set.hsp"
#include "modules/boxfa.hsp"
#include "modules/grid_system/area_grid_system.hsp"

#const global 空点 0
#const global 黒番 1
#const global 白番 2

#module goban board, 手番, 黒が取った数, 白が取った数, コウ禁止点, 最後の着手,手数, stepboard, area_number
#modinit int x, int y, int p1, int p2, int _area
	dim board, x, y
	clear_board thismod
	masx = p1
	masy = p2
	stone_circle = 1 //石を楕円にしない
	area_number = _area
	return
#modfunc clear_board int x, int y
	if x == 0{
		dim board, length(board), length2(board)
		dim stepboard, length(board), length2(board)
	}else: if y == 0{
		dim board, x, x
		dim stepboard , x, x
	}else{
		dim board, x, y
		dim stepboard , x, y
	}
	黒が取った数 = 0
	白が取った数 = 0
	コウ禁止点 = -1,-1
	最後の着手 = -1,-1
	手番 = 黒番
	手数 = 0
	return
#modcfunc get_turn
	return 手番
#defcfunc get_turn_SGFstr int p1
	if p1 == 黒番: return "B"
	if p1 == 白番: return "W"
	return ;error
#modcfunc get_手数
	return 手数
#modfunc 着手 int x, int y

	if ( コウ禁止点 == x && コウ禁止点.1 == y): return 0
	res = 打てるかチェック(board, x, y, 手番)

	if res{

		board(x,y) = 手番
		最後の着手 = x,y
		手数++
		stepboard(x,y) = 手数
		
		repeat num_n
			board(xx(cnt),yy(cnt)) = 空点
		loop
		if 手番 == 黒番: 黒が取った数 += num_n
		if 手番 == 白番: 白が取った数 += num_n

		手番 = 逆手番(手番)

		コウ禁止点 = -1, -1
		
		if num_n = 1{ // コウによる禁止点発生チェック
			tmpxx = xx
			tmpyy = yy
			if 打てるかチェック(board, xx, yy, 手番){
				if num_n = 1{
					コウ禁止点 = tmpxx, tmpyy
				}
			}
		}
	}

	return res
	
#modfunc goban_getcapture array a
	a = 黒が取った数,白が取った数
	return



#defcfunc 打てるかチェック array a, int x, int y,int t

	if x < 0 || x >= length(a): return 0
	if y < 0 || y >= length2(a): return 0
	if a(x,y) != 空点: return 0
	
	dim kk, length(a),length2(a)
	memcpy kk, a, length(a) * length2(a) * 4
	
	kk(x,y) = t

	num_n = 0

	repeat 4
		nnx = x + sx(cnt)
		nny = y + sy(cnt)
		if nnx < 0 || nnx >= length(a): continue
		if nny < 0 || nny >= length2(a): continue
		if kk(nnx,nny) == 逆手番(t){
			if ある地点が取られ状態か？ (kk, nnx, nny ){
				repeat stat
					xx(num_n) = agehamax(cnt)
					yy(num_n) = agehamay(cnt)
					num_n++
				loop
			}
		}
	loop
	
	if num_n = 0 { //一つも取れずに
	
		dim kk, length(a),length2(a)
		memcpy kk, a, length(a) * length2(a) * 4
		
		kk(x,y) = t

		;うとうとしている地点が取られているなら、打てない
		if ある地点が取られ状態か？(kk,x,y): return 0
	}
	
	return 1
#defcfunc ある地点が取られ状態か？ array a, int x, int y
	if a(x,y) == 空点: return 0
	num = 0
	turn = a(x,y)
	aturn = 逆手番(turn)
	sn = 0
	dim b,length(a),length2(a)
	memcpy b,a,length(a)*length2(a)*4
	スタックに積んで置き換える b, x, y, aturn
	
	while sn
		sn--
		nx = stackx(sn)
		ny = stacky(sn)
		for i,,4
			nnx = nx + sx(i)
			nny = ny + sy(i)
			if nnx < 0 || nnx >= length(b): _continue
			if nny < 0 || nny >= length2(b): _continue

			switch b(nnx, nny)
			case 空点: return 0
			case turn
			スタックに積んで置き換える b, nnx, nny, aturn
			swbreak
			swend
		next
	wend
	return num
#deffunc スタックに積んで置き換える array a, int x, int y, int t
	agehamax(num) = x
	agehamay(num) = y
	num++
	stackx(sn) = x
	stacky(sn) = y
	sn++
	a(x,y) = t
	return
#defcfunc 逆手番 int p1
	if p1 == 黒番: return 白番
	if p1 == 白番: return 黒番
	return 空点




#modfunc 碁盤表示 int 碁石番号表示, int margin

	thisrect thismod, r, area_number

	masx = limit((r.2 - r   - margin) / length(board),1)
	masy = limit((r.3 - r.1 - margin) / length2(board),1)

	if stone_circle == 1{
		if masx > masy: masx = masy
		if masy > masx: masy = masx
	}

	//エリアの中心に表示する
	px = r.0 + ( (r.2 - r.0 ) - masx *  length(board))  / 2
	py = r.1 + ( (r.3 - r.1 ) - masy * length2(board))  / 2
	
	//線描画

	color $cd,$85,$3f
	boxf px, py, px + length(board) * masx, py + length2(board) * masy
	color
	repeat length(board)
		line px + masx * cnt + masx / 2, py + masy/2, px + masx * cnt + masx/2, py + masy * length2(board) - masy/2 - 1
	loop
	repeat length2(board)
		line px + masx/2, py + masy * cnt + masy/2, px + masx * length(board) - masx/2 - 1, py + masy * cnt + masy/2
	loop


	//星描画
	if view_hosi{
		
		get_hosi length(board), length2(board), hosilist

		hosisizer = limit(masx / 8,3)
		repeat stat
	
			centerx = px + masx / 2 + masx * hosilist(0, cnt)
			centery = py + masy / 2 + masy * hosilist(1, cnt)
			x1 = centerx - hosisizer
			y1 = centery - hosisizer
			x2 = centerx + hosisizer
			y2 = centery + hosisizer
			
			circle x1, y1, x2, y2
			
		loop
	}

	//石描画

	repeat length(board): m= cnt
		repeat length2(board)
			posx = px + m   * masx
			posy = py + cnt * masy
			pos posx + 4, posy + 2

			//ボード描画
			switch board(m,cnt)
			case 黒番
				color
				circle posx, posy , posx + masx, posy + masy
				gosub*draw_last_move_mark
				if 碁石番号表示{
					color 210,210,210
					mes stepboard(m,cnt)
				}
			swbreak
			case 白番
				color 210,210,210
				circle posx, posy , posx + masx, posy + masy
				gosub*draw_last_move_mark
				if 碁石番号表示{
					color
					mes stepboard(m,cnt)
				}
			swbreak
			case 空点
				if (コウ禁止点 == m) && (コウ禁止点.1 ==cnt){
					
					color 210,21,21
					circle posx + masx/4, posy + masy/4, posx + masx*3/4, posy + masy*3/4
					
				}
				if 碁石番号表示: if stepboard(m,cnt) > 0{
					color, 240
					mes stepboard(m,cnt)
				}
			swbreak
			swend
		loop
	loop

	return

#modfunc Draw_set_list_on_board var set_list

	repeat get_coordinates_set(set_list, sets)
		x = int(strmid(sets(cnt), 0, 2))
		y = int(strmid(sets(cnt), 2, 2))			
		boxfa px + x * masx, py + y * masy ,px + x * masx + masx, py + y * masy + masy
	loop
	
	return
	
#modfunc 碁盤に矩形データを表示 array rects

	
		x1 = rects(0)
		y1 = rects(1)
		x2 = rects(2)
		y2 = rects(3)

		if x1 > x2: tmp = x1:x1 = x2: x2 = tmp
		if y1 > y2: tmp = y1:y1 = y2: y2 = tmp 
		color 200,200,200
		
		boxfa px + (x1 * masx), py + (y1 * masx), px + (x2 * masx) + masx, py + (y2 * masy) + masy
	

	return
*draw_last_move_mark
	if m == 最後の着手 && cnt == 最後の着手.1{
		color 21,220,21
		circle posx + masx/5, posy + masy/5, posx + masx*4/5, posy + masy*4/5
	}
	return
#modfunc getBoardCoordinates array result
	result = (mousex - px) / masx - (mousex < px), (mousey - py) / masy - (mousey < py)
	return

#modfunc get_board_data array a
	dim a,length(board),length2(board)
	repeat length(board): m = cnt
		repeat length2(board)
			a(m,cnt) = board(m,cnt)
		loop
	loop
	return
//各モジュールで追加に必要なコードはこれだけ。コピペ推奨
#modfunc local thisrect array mocklist, int area_number_mock
	if mock_flag@global{
		get_rect_mock mockrect //モックから矩形取得
		mocklist(0) = mockrect(0,area_number_mock)
		mocklist(1) = mockrect(1,area_number_mock)
		mocklist(2) = mockrect(2,area_number_mock)
		mocklist(3) = mockrect(3,area_number_mock) 
	}else{
		get_rect area_number_mock, mocklist //グリッドシステムからエリア番号で矩形取得
	}
	return
#deffunc board_module_init int p1
	sx = 1,0,-1,0
	sy = 0,-1,0,1

	hosisizer = p1
	
	if hosisizer == 0: hosisizer = 3
	return

//盤の大きさを受け取り、星の位置のリストを返す
#deffunc get_hosi int boardsizex, int boardsizey, array a , local n
	
	dim a, 2

	if boardsizex == 9 && boardsizey == 9{
		
		a(0,n) = 5,5
		n++

	}

	if boardsizex == 13 && boardsizey == 13{
		
		a(0,n) = 3,3 : n++
		a(0,n) = 6,3 : n++
		a(0,n) = 9,3 : n++
		a(0,n) = 3,6 : n++
		a(0,n) = 6,6 : n++
		a(0,n) = 9,6 : n++
		a(0,n) = 3,9 : n++
		a(0,n) = 6,9 : n++
		a(0,n) = 9,9 : n++

	
	}

	if boardsizex == 19 && boardsizey == 19{

		a(0,n) = 3,3 : n++
		a(0,n) = 9,3 : n++
		a(0,n) = 15,3 : n++
		a(0,n) = 3,9 : n++
		a(0,n) = 9,9 : n++
		a(0,n) = 15,9 : n++
		a(0,n) = 3,15 : n++
		a(0,n) = 9,15 : n++
		a(0,n) = 15,15 : n++

	}


	return n
#global
board_module_init
#endif

#ifndef search2
#include "modules/ringbuffer.hsp"
#include "modules/bitboard.hsp"
#module

#defcfunc search2 var SGF_list, array 探したい局面, array result, int max_depth,int colorFlip, str mask, int kifu_update, var next_kifuload_index

	
	dim patterns, 23,16
	dim pattern_masks, 23, 8
	sdim node_data
	sdim result,, 2
	result_num = 0

	create_mask 探したい局面, mask, patterns, pattern_masks //patternに16種類, maskに８種類格納する

	/* パターンをログに出力
	for i,,8
		dim vv
		repeat 23
			vv(cnt) = patterns(cnt,i)
		loop
		log_bitboard vv
	next
	stop
	;/*/

	/* マスクをログに出力
	for i,,8
		dim vv
		repeat 23
			vv(cnt) = pattern_masks(cnt,i)
		loop
		log_bitboard vv
	next
	stop
	;/*/
	
	titlestr = ""
	notesel SGF_list
		if kifu_update{		
			repeat , next_kifuload_index
				noteget sgf_filename, cnt
				next_kifuload_index++
				if sgf_filename == "": break
				if get_value(sgf_filename) == NOT_DEFINED_HASH{
					notesel sgf
						noteload sgf_filename
					noteunsel
					topnode = load_sgf(sgf)
					new_value sgf_filename, str(topnode)
					await
					titlestr = "棋譜読み込み中 -> "+ (cnt+1) * 100 / notemax + "%"
					title titlestr
				}
			loop
		}

		init_ringbuffer 64, 128 //キューの初期化（スロットサイズ,初期要素数)
		clear_mem
		starttime = keyfpstime
		repeat notemax
			noteget sgf_filename, cnt
			topnode = int(get_value(sgf_filename))
	　
			if search_main2(topnode, patterns, pattern_masks, 1 + colorflip, max_depth) >= 0{
				result(0, result_num) = sgf_filename
				result(1, result_num) = str(stat)
				result_num++
			}
			
		loop
	noteunsel
	title titlestr + strf("検索完了 %d件 (%dms)", result_num, keyfpstime - starttime)
	return result_num


#defcfunc search_main2 int t, array pattern, array pattern_mask, int colorflip, int max_depth

  lpoke node_data, , 0         //現在の深さ(手数)
  lpoke node_data, 4, t        //ノード番号
  r_push node_data
  
  while ringbuffer_count

    r_shift node_data //キューからノードデータを復元

    //ノードデータ展開
    depth = lpeek(node_data) 
    if depth > max_depth: return -1
    
    node = lpeek(node_data, 4)
    turn = get_property_coordinate_cash(node,x,y)　//ノードの手番と着手座標を取得
    

    if x >= 0{
	    copy_bitboard_data get_bitboard(node), board
	   	for j,,8 //回転
	   		if memorize_hit_mask(j, x, y, pattern_mask){ //ノードの着手がmaskにない場合、このノードでは一致しない。
		   		for i,,colorflip //色反転
	
		    		OK = 1
		    		repeat 23
		    			bd = board(cnt) //盤面
		    			pt = pattern(cnt, j + i * 8)　//パターン
		    			mk = pattern_mask(cnt, j) //マスク
		    			if ((bd ^ pt) & mk) != 0{
		    				OK = 0
			    			break
			    		}
		    		loop
		    		if OK{ //盤面が一致した
			    		return node
			    	}
		    	next
		    }
	    next
	}
    repeat get_SGF_childs(node, child)
      lpoke node_data,  , depth + 1
      lpoke node_data, 4, lpeek(child, cnt * 4)
      r_push node_data
    loop
  wend
  
  return -1

#global
#endif